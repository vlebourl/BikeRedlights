# Scenario 1: Normal Ride (Start â†’ Wait 20s â†’ Stop)

## Overview
User starts a ride, waits for GPS, rides for 20 seconds, then stops.

**Auto-pause**: OFF
**Expected outcome**: Ride saved with 20s duration (minus GPS initialization time)

---

## Step-by-Step Code Execution Trace

### **STEP 1: User navigates to Live Ride screen**

**Location**: `LiveRideScreen.kt:81-112`

```kotlin
LaunchedEffect(uiState) {
    if (uiState is RideRecordingUiState.Idle && hasLocationPermissions(context)) {
        // GPS pre-warming logic
        fusedLocationClient.getCurrentLocation(Priority.PRIORITY_HIGH_ACCURACY, ...)
    }
}
```

**State**:
- `uiState = RideRecordingUiState.Idle`
- GPS Status: "GPS Off"
- GPS pre-warming: INITIATED (background request)

**Variables**:
- No ride exists yet
- ViewModel state: Idle

**âœ“ CHECKPOINT**: GPS pre-warming starts in background, may complete before user taps "Start Ride"

---

### **STEP 2: User taps "Start Ride" button** (t=0s)

**Location**: `LiveRideScreen.kt:217` â†’ `RideRecordingViewModel.kt:83-84`

```kotlin
fun startRide() {
    RideRecordingService.startRecording(context)
}
```

**Location**: `RideRecordingService.kt:startRecording()` â†’ `onStartCommand()` â†’ `startRecording()`

**State**:
- Service starts in foreground
- `currentRideId = null` initially

**Action**: Service calls `startRideUseCase()`

---

### **STEP 3: Create new ride**

**Location**: `StartRideUseCase.kt:57-78`

```kotlin
suspend operator fun invoke(): Long {
    val currentTime = System.currentTimeMillis()  // e.g., 1000000000000
    val rideName = RideNameGenerator.generateDefaultName(currentTime)

    val newRide = Ride(
        id = 0,  // Auto-generated by database
        name = rideName,
        startTime = 0,  // Bug #14: Will be set when first track point is recorded
        endTime = null,
        elapsedDurationMillis = 0,
        movingDurationMillis = 0,
        manualPausedDurationMillis = 0,
        autoPausedDurationMillis = 0,
        distanceMeters = 0.0,
        avgSpeedMetersPerSec = 0.0,
        maxSpeedMetersPerSec = 0.0
    )

    return rideRepository.createRide(newRide)  // Returns id = 1
}
```

**Variables**:
- Ride created in database with id=1
- **CRITICAL**: `ride.startTime = 0` (GPS not ready yet)
- All durations = 0
- All distances = 0

**State**:
- `currentRideId = 1`
- Service updates state: `RideRecordingState.Recording(rideId=1)`

---

### **STEP 4: ViewModel observes new state**

**Location**: `RideRecordingViewModel.kt:304-319`

```kotlin
is RideRecordingState.Recording -> {
    rideObservationJob = viewModelScope.launch {
        rideRepository.getRideByIdFlow(recordingState.rideId).collect { ride ->
            _uiState.value = if (ride != null) {
                // Bug #14 fix: Check if startTime == 0
                if (ride.startTime == 0L) {
                    RideRecordingUiState.WaitingForGps(ride)  // â† THIS BRANCH
                } else {
                    RideRecordingUiState.Recording(ride)
                }
            } else {
                RideRecordingUiState.Idle
            }
        }
    }
}
```

**UI State**: `RideRecordingUiState.WaitingForGps(ride)`
- GPS Status: "GPS Searching..."
- UI shows spinner: "Waiting for GPS..."

**âœ“ CHECKPOINT**: Ride exists but startTime=0, UI correctly shows waiting state

---

### **STEP 5: GPS location updates start** (t=3s, GPS initialized)

**Location**: Service starts collecting location updates

```kotlin
locationRepository.getLocationUpdates().collect { locationData ->
    // First location received after ~3 seconds
}
```

**First Location Data**:
```kotlin
LocationData(
    latitude = 37.422,
    longitude = -122.084,
    speedMps = 0.0f,
    accuracy = 20.0f,
    timestamp = 1000000003000  // 3 seconds after ride creation
)
```

---

### **STEP 6: Record first track point** (t=3s)

**Location**: `RecordTrackPointUseCase.kt:53-81`

```kotlin
suspend operator fun invoke(
    rideId: Long,
    locationData: LocationData,
    isManuallyPaused: Boolean = false,
    isAutoPaused: Boolean = false
): Long {
    // Bug #14: Set ride startTime on first track point
    val ride = rideRepository.getRideById(rideId)  // ride.startTime = 0
    if (ride != null && ride.startTime == 0L) {
        val updatedRide = ride.copy(startTime = locationData.timestamp)  // 1000000003000
        rideRepository.updateRide(updatedRide)
        Log.d("RecordTrackPointUseCase", "Bug #14: Set ride startTime=${locationData.timestamp}")
    }

    val trackPoint = TrackPoint(
        id = 0,
        rideId = rideId,
        timestamp = 1000000003000,
        latitude = 37.422,
        longitude = -122.084,
        speedMetersPerSec = 0.0,
        accuracy = 20.0f,
        isManuallyPaused = false,
        isAutoPaused = false
    )

    return trackPointRepository.insertTrackPoint(trackPoint)
}
```

**Database Update**:
- Ride updated: `startTime = 1000000003000`
- Track point #1 inserted

**âœ“ CHECKPOINT**: startTime now set to actual GPS time, not button press time

---

### **STEP 7: UI updates to Recording state** (t=3s)

**Location**: `RideRecordingViewModel.kt:310-313`

The Flow emits updated ride with `startTime != 0`:

```kotlin
if (ride.startTime == 0L) {
    RideRecordingUiState.WaitingForGps(ride)
} else {
    RideRecordingUiState.Recording(ride)  // â† NOW THIS BRANCH
}
```

**UI State**: `RideRecordingUiState.Recording(ride)`
- GPS Status: "GPS Ready"
- Timer visible, starts counting

---

### **STEP 8: Timer updates every second** (t=3s to t=23s)

**Location**: `RideStatistics.kt:64-78`

```kotlin
var currentDuration by remember(ride.id) { mutableStateOf(0L) }

LaunchedEffect(ride.id, ride.startTime, ride.endTime) {
    if (ride.endTime == null && ride.startTime != 0L) {
        // Active ride: update duration every second
        while (true) {
            val now = System.currentTimeMillis()  // e.g., 1000000010000 (t=10s)
            val elapsed = now - ride.startTime    // 10000 - 3000 = 7000ms
            val paused = ride.manualPausedDurationMillis + ride.autoPausedDurationMillis  // 0 + 0 = 0
            currentDuration = (elapsed - paused).coerceAtLeast(0L)  // 7000ms
            delay(1000)
        }
    }
}
```

**Timer Display at t=10s**:
- `elapsed = 10000 - 3000 = 7000ms`
- `currentDuration = 7000ms`
- **Display**: "00:00:07"

**Timer Display at t=23s**:
- `elapsed = 23000 - 3000 = 20000ms`
- `currentDuration = 20000ms`
- **Display**: "00:00:20"

**âœ“ CHECKPOINT**: Timer shows accurate moving time (excludes GPS init delay)

---

### **STEP 9: GPS updates continue** (t=3s to t=23s)

Every ~1 second, new location updates arrive:
- Track points inserted continuously
- Distance calculated and accumulated
- Speed updated

**No pauses**, so:
- `manualPausedDurationMillis = 0`
- `autoPausedDurationMillis = 0`
- `movingDurationMillis` not updated yet (happens on finish)

---

### **STEP 10: User taps "Stop Ride"** (t=23s)

**Location**: `RideRecordingViewModel.kt:126-213`

```kotlin
fun stopRide() {
    viewModelScope.launch {
        val state = rideRecordingStateRepository.getCurrentState()
        val rideId = state.currentRideId ?: return@launch  // rideId = 1

        // Bug #13 fix: Check if paused
        if (state is RideRecordingState.ManuallyPaused || state is RideRecordingState.AutoPaused) {
            // NOT IN THIS BRANCH (not paused)
        }

        // Bug #7 fix: Cancel ride observation
        rideObservationJob?.cancel()
        rideObservationJob?.join()
        rideObservationJob = null

        // Stop service
        RideRecordingService.stopRecording(context)

        // Finish ride
        when (val result = finishRideUseCase(rideId)) {
            is FinishRideResult.Success -> {
                _uiState.value = RideRecordingUiState.ShowingSaveDialog(result.ride)
            }
            is FinishRideResult.TooShort -> {
                discardRide(rideId)
                _uiState.value = RideRecordingUiState.Idle
            }
            is FinishRideResult.RideNotFound -> {
                _uiState.value = RideRecordingUiState.Idle
            }
        }
    }
}
```

**âœ“ CHECKPOINT**: Observation job cancelled to prevent race conditions

---

### **STEP 11: Finish ride** (t=23s)

**Location**: `FinishRideUseCase.kt:50-82`

```kotlin
suspend operator fun invoke(rideId: Long): FinishRideResult {
    val ride = rideRepository.getRideById(rideId)
        ?: return FinishRideResult.RideNotFound

    val endTime = System.currentTimeMillis()  // 1000000023000

    // Calculate elapsed duration
    val elapsedDuration = endTime - ride.startTime  // 23000 - 3000 = 20000ms

    // Calculate moving duration (Bug #13 fix: uses accumulated pause durations)
    val movingDuration = elapsedDuration - ride.manualPausedDurationMillis - ride.autoPausedDurationMillis
    // movingDuration = 20000 - 0 - 0 = 20000ms

    // Validate minimum duration (5 seconds)
    if (movingDuration < MIN_RIDE_DURATION_MILLIS) {  // 20000 >= 5000 âœ“
        return FinishRideResult.TooShort(movingDuration)
    }

    // Update ride
    val finishedRide = ride.copy(
        endTime = endTime,  // 1000000023000
        elapsedDurationMillis = elapsedDuration,  // 20000
        movingDurationMillis = movingDuration  // 20000
    )

    rideRepository.updateRide(finishedRide)

    return FinishRideResult.Success(finishedRide)
}
```

**Ride Final State**:
```kotlin
Ride(
    id = 1,
    name = "Ride on Nov 6, 2025",
    startTime = 1000000003000,
    endTime = 1000000023000,
    elapsedDurationMillis = 20000,
    movingDurationMillis = 20000,
    manualPausedDurationMillis = 0,
    autoPausedDurationMillis = 0,
    distanceMeters = 120.5,  // example
    avgSpeedMetersPerSec = 6.0,
    maxSpeedMetersPerSec = 8.5
)
```

**âœ“ CHECKPOINT**: Durations correctly calculated, ride valid (>5s)

---

### **STEP 12: Show save dialog** (t=23s)

**Location**: `RideRecordingViewModel.kt:193-197`

```kotlin
is FinishRideResult.Success -> {
    _uiState.value = RideRecordingUiState.ShowingSaveDialog(result.ride)
}
```

**UI State**: `RideRecordingUiState.ShowingSaveDialog(ride)`
- Dialog appears with ride statistics
- Options: Save / Discard

---

### **STEP 13: User taps "Save"**

**Location**: `RideRecordingViewModel.kt:224-239`

```kotlin
fun saveRide() {
    val state = _uiState.value
    if (state is RideRecordingUiState.ShowingSaveDialog) {
        viewModelScope.launch {
            val rideId = state.ride.id  // 1

            // Clear recording state
            rideRecordingStateRepository.clearRecordingState()

            // Return to Idle
            _uiState.value = RideRecordingUiState.Idle

            // Navigate to Review
            _navigationEvents.send(NavigationEvent.NavigateToReview(rideId))
        }
    }
}
```

**State**:
- Ride kept in database
- Recording state cleared
- UI returns to Idle
- Navigation to Review screen

**âœ“ CHECKPOINT**: Clean state transition, ride preserved

---

## Final Analysis

### âœ… **PASSED Checks**:
1. âœ… **Variable Initialization**: All ride fields correctly initialized to 0
2. âœ… **startTime Lifecycle**: Set to 0 initially, updated on first GPS fix
3. âœ… **Timer Accuracy**: Shows moving time only (GPS init delay excluded)
4. âœ… **Duration Calculation**: `movingDuration = elapsed - pauses` âœ“
5. âœ… **Race Condition Prevention**: Observation job cancelled before finishing
6. âœ… **State Transitions**: Idle â†’ WaitingForGps â†’ Recording â†’ ShowingSaveDialog â†’ Idle
7. âœ… **Minimum Duration Validation**: 20s > 5s threshold âœ“
8. âœ… **State Cleanup**: Recording state cleared on save

### ðŸš¨ **POTENTIAL ISSUES**: None identified

### ðŸ“Š **Timing Breakdown**:
- t=0s: User taps "Start Ride"
- t=0s-3s: GPS initialization (WaitingForGps state)
- t=3s: First GPS fix, startTime set, Recording starts
- t=3s-23s: Active recording (20s moving time)
- t=23s: User stops, ride finished
- **Result**: 20s ride saved âœ“

---

## Conclusion

**Scenario 1 PASSES** all checks. The normal ride flow works correctly with:
- Proper GPS initialization handling
- Accurate timer display
- Correct duration calculations
- Clean state management
- No race conditions detected
