# Data Model: Ride History and List View

**Feature**: 003-ride-history-list
**Phase**: 1 (Design & Contracts)
**Date**: 2025-11-06
**Purpose**: Define data structures, entities, display models, and validation rules for ride history feature

## Domain Models

### 1. Ride (Existing - From F1A v0.3.0)

**Purpose**: Core domain model representing a completed cycling session

**Location**: `domain/model/Ride.kt`

**Structure**:
```kotlin
data class Ride(
    val id: Long,
    val name: String,
    val startTime: Instant,
    val endTime: Instant,
    val durationSeconds: Long,
    val distanceMeters: Float,
    val avgSpeedMps: Float,
    val maxSpeedMps: Float,
    val totalPausedSeconds: Long,
    val pauseCount: Int
)
```

**Fields**:
- `id`: Unique identifier (Long, auto-generated by Room)
- `name`: Human-readable name (e.g., "Ride on Nov 4, 2025")
- `startTime`: When ride recording started (Instant, UTC)
- `endTime`: When ride recording stopped (Instant, UTC)
- `durationSeconds`: Total active ride duration (excludes paused time)
- `distanceMeters`: Total distance traveled (meters, base unit)
- `avgSpeedMps`: Average speed (meters per second, base unit)
- `maxSpeedMps`: Maximum speed achieved (meters per second, base unit)
- `totalPausedSeconds`: Total time spent paused (manual + auto-pause)
- `pauseCount`: Number of times ride was paused

**Validation Rules** (Enforced in data layer):
- `id > 0` (after database insert)
- `name` not blank
- `endTime >= startTime`
- `durationSeconds >= 0`
- `distanceMeters >= 0`
- `avgSpeedMps >= 0`
- `maxSpeedMps >= avgSpeedMps`
- `totalPausedSeconds >= 0`
- `pauseCount >= 0`

**Relationships**:
- One-to-Many with TrackPoint (ride has many GPS coordinates)

**Notes**:
- This entity already exists from F1A (v0.3.0)
- No schema changes needed for history feature
- Room entity mirrors this structure in `data/local/entity/RideEntity.kt`

---

### 2. RideListItem (New - Display Model)

**Purpose**: Optimized display model for ride list items with pre-formatted strings

**Location**: `domain/model/display/RideListItem.kt`

**Structure**:
```kotlin
data class RideListItem(
    val id: Long,
    val name: String,
    val dateFormatted: String,           // e.g., "Nov 4, 2025"
    val durationFormatted: String,       // e.g., "1:23:45"
    val distanceFormatted: String,       // e.g., "12.5 km" or "7.8 mi"
    val avgSpeedFormatted: String,       // e.g., "18.3 km/h" or "11.4 mph"
    val startTimeMillis: Long            // For sorting purposes
)
```

**Fields**:
- `id`: Ride identifier for navigation
- `name`: Ride name (unformatted, for display)
- `dateFormatted`: Localized date string (DateTimeFormatter with user locale)
- `durationFormatted`: HH:MM:SS or H:MM:SS format
- `distanceFormatted`: Distance with unit symbol (respects user preference)
- `avgSpeedFormatted`: Average speed with unit symbol (respects user preference)
- `startTimeMillis`: Epoch milliseconds for efficient sorting

**Creation**:
- Created in ViewModel by mapping Ride → RideListItem
- Formatting done once per ride, not per recomposition
- All strings pre-computed to avoid expensive operations in composables

**Example Mapping**:
```kotlin
fun Ride.toListItem(unitPreference: UnitPreference): RideListItem {
    val dateFormatter = DateTimeFormatter
        .ofLocalizedDate(FormatStyle.MEDIUM)
        .withLocale(Locale.getDefault())

    return RideListItem(
        id = id,
        name = name,
        dateFormatted = startTime.atZone(ZoneId.systemDefault())
            .toLocalDate()
            .format(dateFormatter),
        durationFormatted = formatDuration(durationSeconds),
        distanceFormatted = when (unitPreference) {
            UnitPreference.METRIC -> "%.1f km".format(distanceMeters / 1000f)
            UnitPreference.IMPERIAL -> "%.1f mi".format(distanceMeters / 1609.34f)
        },
        avgSpeedFormatted = when (unitPreference) {
            UnitPreference.METRIC -> "%.1f km/h".format(avgSpeedMps * 3.6f)
            UnitPreference.IMPERIAL -> "%.1f mph".format(avgSpeedMps * 2.23694f)
        },
        startTimeMillis = startTime.toEpochMilli()
    )
}
```

---

### 3. RideDetailData (New - Display Model)

**Purpose**: Complete display model for ride detail screen with all statistics formatted

**Location**: `domain/model/display/RideDetailData.kt`

**Structure**:
```kotlin
data class RideDetailData(
    val id: Long,
    val name: String,
    val startTimeFormatted: String,      // e.g., "Nov 4, 2025 at 2:30 PM"
    val endTimeFormatted: String,        // e.g., "Nov 4, 2025 at 4:05 PM"
    val durationFormatted: String,       // e.g., "1:23:45"
    val distanceFormatted: String,       // e.g., "12.5 km"
    val avgSpeedFormatted: String,       // e.g., "18.3 km/h"
    val maxSpeedFormatted: String,       // e.g., "42.7 km/h"
    val pausedTimeFormatted: String,     // e.g., "0:05:30"
    val pauseCount: Int,                 // e.g., 3
    val hasPauses: Boolean               // true if totalPausedSeconds > 0
)
```

**Fields**:
- `id`: Ride identifier
- `name`: Ride name
- `startTimeFormatted`: Localized start date/time
- `endTimeFormatted`: Localized end date/time
- `durationFormatted`: Active ride duration (HH:MM:SS)
- `distanceFormatted`: Total distance with unit
- `avgSpeedFormatted`: Average speed with unit
- `maxSpeedFormatted`: Maximum speed with unit
- `pausedTimeFormatted`: Total paused time (HH:MM:SS)
- `pauseCount`: Number of pauses (raw integer)
- `hasPauses`: Whether to show pause section in UI

**Creation**:
```kotlin
fun Ride.toDetailData(unitPreference: UnitPreference): RideDetailData {
    val dateTimeFormatter = DateTimeFormatter
        .ofLocalizedDateTime(FormatStyle.MEDIUM, FormatStyle.SHORT)
        .withLocale(Locale.getDefault())

    return RideDetailData(
        id = id,
        name = name,
        startTimeFormatted = startTime.atZone(ZoneId.systemDefault())
            .format(dateTimeFormatter),
        endTimeFormatted = endTime.atZone(ZoneId.systemDefault())
            .format(dateTimeFormatter),
        durationFormatted = formatDuration(durationSeconds),
        distanceFormatted = formatDistance(distanceMeters, unitPreference),
        avgSpeedFormatted = formatSpeed(avgSpeedMps, unitPreference),
        maxSpeedFormatted = formatSpeed(maxSpeedMps, unitPreference),
        pausedTimeFormatted = formatDuration(totalPausedSeconds),
        pauseCount = pauseCount,
        hasPauses = totalPausedSeconds > 0
    )
}
```

---

## Preferences Models

### 4. SortPreference (New - Settings Model)

**Purpose**: Enum for ride list sort options

**Location**: `domain/model/settings/SortPreference.kt`

**Structure**:
```kotlin
enum class SortPreference {
    NEWEST_FIRST,      // Default: Order by startTime DESC
    OLDEST_FIRST,      // Order by startTime ASC
    LONGEST_DISTANCE,  // Order by distanceMeters DESC
    LONGEST_DURATION;  // Order by durationSeconds DESC

    val displayName: String
        get() = when (this) {
            NEWEST_FIRST -> "Newest First"
            OLDEST_FIRST -> "Oldest First"
            LONGEST_DISTANCE -> "Longest Distance"
            LONGEST_DURATION -> "Longest Duration"
        }
}
```

**Persistence**:
- Stored in DataStore Preferences as String
- Key: `preferences_key_sort_preference`
- Default: `NEWEST_FIRST`

**Validation**:
- Must be one of enum values
- Invalid value falls back to `NEWEST_FIRST`

---

### 5. DateRangeFilter (New - Settings Model)

**Purpose**: Sealed class for date range filtering options

**Location**: `domain/model/settings/DateRangeFilter.kt`

**Structure**:
```kotlin
sealed class DateRangeFilter {
    object AllTime : DateRangeFilter()
    object Last7Days : DateRangeFilter()
    object Last30Days : DateRangeFilter()
    object ThisYear : DateRangeFilter()
    data class CustomRange(
        val startMillis: Long,
        val endMillis: Long
    ) : DateRangeFilter()

    val displayName: String
        get() = when (this) {
            is AllTime -> "All Time"
            is Last7Days -> "Last 7 Days"
            is Last30Days -> "Last 30 Days"
            is ThisYear -> "This Year"
            is CustomRange -> {
                val startDate = Instant.ofEpochMilli(startMillis)
                    .atZone(ZoneId.systemDefault())
                    .toLocalDate()
                val endDate = Instant.ofEpochMilli(endMillis)
                    .atZone(ZoneId.systemDefault())
                    .toLocalDate()
                val formatter = DateTimeFormatter.ofPattern("MMM d, yyyy")
                "${startDate.format(formatter)} - ${endDate.format(formatter)}"
            }
        }

    val isActive: Boolean
        get() = this !is AllTime

    fun matches(rideStartTime: Instant): Boolean {
        val now = Instant.now()
        val rideMillis = rideStartTime.toEpochMilli()

        return when (this) {
            is AllTime -> true
            is Last7Days -> {
                val cutoff = now.minus(7, ChronoUnit.DAYS).toEpochMilli()
                rideMillis >= cutoff
            }
            is Last30Days -> {
                val cutoff = now.minus(30, ChronoUnit.DAYS).toEpochMilli()
                rideMillis >= cutoff
            }
            is ThisYear -> {
                val rideYear = rideStartTime.atZone(ZoneId.systemDefault()).year
                val currentYear = now.atZone(ZoneId.systemDefault()).year
                rideYear == currentYear
            }
            is CustomRange -> {
                rideMillis in startMillis..endMillis
            }
        }
    }
}
```

**Persistence**:
- Stored in DataStore Preferences as JSON string
- Key: `preferences_key_date_filter`
- Default: `AllTime`
- Serialization: Kotlin serialization or manual JSON encoding

**Validation**:
- CustomRange: `endMillis >= startMillis`
- CustomRange: `endMillis <= now` (can't filter future rides)
- Invalid JSON falls back to `AllTime`

---

## UI State Models

### 6. RideHistoryUiState (New - ViewModel State)

**Purpose**: Sealed class representing loading/success/error states for history screen

**Location**: `ui/viewmodel/RideHistoryViewModel.kt` (internal to ViewModel)

**Structure**:
```kotlin
sealed interface RideHistoryUiState {
    object Loading : RideHistoryUiState

    data class Success(
        val rides: List<RideListItem>,
        val isEmpty: Boolean = rides.isEmpty()
    ) : RideHistoryUiState

    data class Error(val message: String) : RideHistoryUiState
}
```

**State Transitions**:
1. Initial: `Loading`
2. On successful load: `Loading` → `Success(rides)`
3. On error: `Loading` → `Error(message)`
4. On retry: `Error` → `Loading`
5. On delete: `Success` → `Success` (with updated list via Flow)

---

### 7. RideDetailUiState (New - ViewModel State)

**Purpose**: Sealed class representing loading/success/error states for detail screen

**Location**: `ui/viewmodel/RideDetailViewModel.kt` (internal to ViewModel)

**Structure**:
```kotlin
sealed interface RideDetailUiState {
    object Loading : RideDetailUiState

    data class Success(val rideDetail: RideDetailData) : RideDetailUiState

    data class Error(val message: String) : RideDetailUiState
}
```

**State Transitions**:
1. Initial: `Loading`
2. On successful load: `Loading` → `Success(rideDetail)`
3. On error (ride not found): `Loading` → `Error("Ride not found")`
4. On ride deleted elsewhere: `Success` → navigate back to history

---

## Data Layer Entities (Existing)

### 8. RideEntity (Existing - Room Entity)

**Purpose**: Room database entity for rides table

**Location**: `data/local/entity/RideEntity.kt`

**Structure**:
```kotlin
@Entity(tableName = "rides")
data class RideEntity(
    @PrimaryKey(autoGenerate = true)
    val id: Long = 0,
    val name: String,
    val startTime: Long,           // Epoch milliseconds
    val endTime: Long,             // Epoch milliseconds
    val durationSeconds: Long,
    val distanceMeters: Float,
    val avgSpeedMps: Float,
    val maxSpeedMps: Float,
    val totalPausedSeconds: Long,
    val pauseCount: Int
)
```

**Mapping to Domain**:
```kotlin
fun RideEntity.toDomain(): Ride = Ride(
    id = id,
    name = name,
    startTime = Instant.ofEpochMilli(startTime),
    endTime = Instant.ofEpochMilli(endTime),
    durationSeconds = durationSeconds,
    distanceMeters = distanceMeters,
    avgSpeedMps = avgSpeedMps,
    maxSpeedMps = maxSpeedMps,
    totalPausedSeconds = totalPausedSeconds,
    pauseCount = pauseCount
)
```

**Note**: No changes needed to this entity for history feature. All data already available.

---

## Repository Contracts

### 9. RideRepository Interface (Existing - Extended)

**Purpose**: Define contract for ride data operations

**Location**: `domain/repository/RideRepository.kt`

**Methods**:
```kotlin
interface RideRepository {
    // EXISTING METHODS (from F1A v0.3.0)
    fun getAllRides(): Flow<List<Ride>>
    suspend fun getRideById(id: Long): Ride?
    suspend fun insertRide(ride: Ride): Long
    suspend fun deleteRide(rideId: Long)

    // NO NEW METHODS NEEDED
    // getAllRides() already returns Flow for reactive updates
    // getRideById() sufficient for detail screen
    // deleteRide() handles cascade deletion of TrackPoints
}
```

**Implementation Notes**:
- `getAllRides()` returns Flow → UI reactively updates when data changes
- Sorting/filtering applied in ViewModel, not repository (keeps repo simple)
- Room cascade delete constraint handles TrackPoint cleanup

---

### 10. UserPreferencesRepository Interface (Existing - Extended)

**Purpose**: Define contract for user preference operations

**Location**: `domain/repository/UserPreferencesRepository.kt`

**Methods**:
```kotlin
interface UserPreferencesRepository {
    // EXISTING METHODS (from F2A v0.2.0)
    fun getUnitPreference(): Flow<UnitPreference>
    suspend fun setUnitPreference(preference: UnitPreference)

    // NEW METHODS (for history feature)
    fun getSortPreference(): Flow<SortPreference>
    suspend fun setSortPreference(preference: SortPreference)

    fun getDateFilter(): Flow<DateRangeFilter>
    suspend fun setDateFilter(filter: DateRangeFilter)
}
```

**Implementation**:
- DataStore Preferences backing storage
- Flow-based reactive reads
- Suspend functions for writes
- Type-safe preference keys

---

## Utility Functions

### 11. FormatUtils (Existing - Extended)

**Purpose**: Centralized formatting functions for duration, distance, speed, dates

**Location**: `domain/util/FormatUtils.kt`

**Functions**:
```kotlin
object FormatUtils {
    // EXISTING (from F1A)
    fun formatSpeed(mps: Float, unit: UnitPreference): String

    fun formatDistance(meters: Float, unit: UnitPreference): String

    // NEW (for history feature)
    fun formatDuration(seconds: Long): String {
        val hours = seconds / 3600
        val minutes = (seconds % 3600) / 60
        val secs = seconds % 60

        return when {
            hours > 0 -> "%d:%02d:%02d".format(hours, minutes, secs)
            else -> "%d:%02d".format(minutes, secs)
        }
    }

    fun formatDate(instant: Instant): String {
        return instant.atZone(ZoneId.systemDefault())
            .toLocalDate()
            .format(DateTimeFormatter.ofLocalizedDate(FormatStyle.MEDIUM))
    }

    fun formatDateTime(instant: Instant): String {
        return instant.atZone(ZoneId.systemDefault())
            .format(
                DateTimeFormatter.ofLocalizedDateTime(
                    FormatStyle.MEDIUM,
                    FormatStyle.SHORT
                )
            )
    }
}
```

---

## Validation Rules Summary

| Model | Field | Rule | Enforced Where |
|-------|-------|------|----------------|
| Ride | id | > 0 | Room (auto-generate) |
| Ride | name | not blank | UseCase / ViewModel |
| Ride | endTime | >= startTime | UseCase |
| Ride | durationSeconds | >= 0 | Data layer |
| Ride | distanceMeters | >= 0 | Data layer |
| Ride | avgSpeedMps | >= 0 | Data layer |
| Ride | maxSpeedMps | >= avgSpeedMps | Data layer |
| DateRangeFilter.CustomRange | endMillis | >= startMillis | UI (date picker) |
| DateRangeFilter.CustomRange | endMillis | <= now | UI (date picker) |

---

## State Flow Diagram

```
ViewModel Initialization
    ↓
Observe: getAllRides() Flow from Repository
    ↓
Observe: getSortPreference() Flow
    ↓
Observe: getDateFilter() Flow
    ↓
combine(rides, sort, filter)
    ↓
Apply filter: rides.filter { filter.matches(it.startTime) }
    ↓
Apply sort: rides.sortedWith(comparator)
    ↓
Map to display model: rides.map { it.toListItem(unit) }
    ↓
Emit: RideHistoryUiState.Success(listItems)
    ↓
UI collects and displays
```

**Reactive Updates**:
- When ride deleted → Room emits updated list → Flow propagates → UI updates
- When sort changed → DataStore emits → combine() recalculates → UI updates
- When filter changed → DataStore emits → combine() recalculates → UI updates

---

## Testing Considerations

### Data Model Tests
- **Ride.toListItem()**: Unit tests for formatting with different locales and units
- **Ride.toDetailData()**: Unit tests for all field mappings
- **DateRangeFilter.matches()**: Unit tests for all filter types and edge cases
- **FormatUtils**: Unit tests for duration/date/time formatting edge cases

### Repository Tests
- **RideRepositoryImpl**: Integration tests with in-memory Room database
- **UserPreferencesRepository**: Integration tests with test DataStore

### ViewModel Tests
- **RideHistoryViewModel**: Unit tests with MockK, Turbine for Flow assertions
- **State transitions**: Loading → Success → Error scenarios
- **Sort/Filter logic**: Verify correct ordering and filtering

---

## Migration Strategy

**Database Migration**: None required
- No schema changes to rides or track_points tables
- All necessary data already captured by F1A (v0.3.0)

**Preferences Migration**: None required
- New preferences (sort, filter) use new keys
- Existing unit preference unaffected
- Defaults handle first-time access

**Data Compatibility**: Full backward compatibility
- All existing rides from v0.3.0 display correctly
- No data transformation needed
