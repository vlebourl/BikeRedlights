package com.example.bikeredlights.domain.usecase

import com.example.bikeredlights.domain.model.LocationData
import com.example.bikeredlights.domain.model.TrackPoint
import com.example.bikeredlights.domain.repository.RideRepository
import com.example.bikeredlights.domain.repository.TrackPointRepository
import javax.inject.Inject

/**
 * Use case for recording a GPS track point during a ride.
 *
 * **Business Logic**:
 * - Converts LocationData (from GPS) to TrackPoint (domain model)
 * - Associates track point with current ride ID
 * - Records pause state (manual/auto)
 * - Bug #14: Sets ride startTime on first track point (when GPS actually starts)
 * - Persists to database
 *
 * **Data Conversion**:
 * - LocationData (GPS layer) â†’ TrackPoint (domain layer)
 * - Extracts lat/lon, speed, accuracy, timestamp
 * - Adds ride association and pause state
 *
 * **Use Case Flow**:
 * 1. RideRecordingService receives GPS update (LocationData)
 * 2. Service calls RecordTrackPointUseCase(rideId, locationData, pauseState)
 * 3. Use case creates TrackPoint from LocationData
 * 4. Bug #14: If first track point (startTime = 0), set ride startTime
 * 5. Repository persists to Room database
 * 6. Returns track point ID
 *
 * **Performance**:
 * - Called every GPS update (~1 second)
 * - Database write on Dispatchers.IO (non-blocking)
 * - Batch insert available via repository if needed
 *
 * @property trackPointRepository Repository for track point persistence
 * @property rideRepository Repository for ride updates (Bug #14)
 */
class RecordTrackPointUseCase @Inject constructor(
    private val trackPointRepository: TrackPointRepository,
    private val rideRepository: RideRepository
) {
    /**
     * Record a GPS track point for a ride.
     *
     * @param rideId Database ID of the current ride
     * @param locationData GPS location data from FusedLocationProviderClient
     * @param isManuallyPaused True if user manually paused recording
     * @param isAutoPaused True if auto-paused due to low speed
     * @return Track point ID (auto-generated by database)
     */
    suspend operator fun invoke(
        rideId: Long,
        locationData: LocationData,
        isManuallyPaused: Boolean = false,
        isAutoPaused: Boolean = false
    ): Long {
        // Bug #14 fix: Set ride startTime on first track point (when GPS is actually working)
        // This ensures timer starts from actual GPS fix, not button press
        val ride = rideRepository.getRideById(rideId)
        if (ride != null && ride.startTime == 0L) {
            val updatedRide = ride.copy(startTime = locationData.timestamp)
            rideRepository.updateRide(updatedRide)
        }

        val trackPoint = TrackPoint(
            id = 0,  // Auto-generated by database
            rideId = rideId,
            timestamp = locationData.timestamp,
            latitude = locationData.latitude,
            longitude = locationData.longitude,
            speedMetersPerSec = locationData.speedMps?.toDouble() ?: 0.0,
            accuracy = locationData.accuracy,
            isManuallyPaused = isManuallyPaused,
            isAutoPaused = isAutoPaused
        )

        return trackPointRepository.insertTrackPoint(trackPoint)
    }
}
