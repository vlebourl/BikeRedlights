package com.example.bikeredlights.domain.usecase

import com.example.bikeredlights.domain.model.Ride
import com.example.bikeredlights.domain.repository.RideRepository
import com.example.bikeredlights.domain.util.RideNameGenerator
import javax.inject.Inject

/**
 * Use case for starting a new ride recording session.
 *
 * **Business Logic**:
 * - Creates a new Ride entity with generated name
 * - Sets startTime to current timestamp
 * - Initializes all statistics to zero
 * - Persists ride to database
 * - Returns ride ID for tracking
 *
 * **Responsibilities**:
 * - Generate default ride name ("Ride on MMM d, yyyy")
 * - Initialize ride with zero statistics
 * - Persist to database via repository
 *
 * **Use Case Flow**:
 * 1. User taps "Start Ride" button
 * 2. ViewModel calls StartRideUseCase
 * 3. Use case creates Ride with current timestamp
 * 4. Repository persists to Room database
 * 5. Returns ride ID to ViewModel
 * 6. ViewModel updates UI state to "Recording"
 *
 * **Error Handling**:
 * - Database write failures propagate as exceptions
 * - Caller should handle exceptions (e.g., show error toast)
 *
 * **Thread Safety**:
 * - This is a suspend function (runs on coroutine)
 * - Repository uses Dispatchers.IO for database operations
 * - Safe to call from any coroutine scope
 *
 * @property rideRepository Repository for ride persistence
 */
class StartRideUseCase @Inject constructor(
    private val rideRepository: RideRepository
) {
    /**
     * Start a new ride recording session.
     *
     * Creates a new Ride entity with:
     * - Generated name: "Ride on Nov 4, 2025"
     * - startTime: Current Unix epoch milliseconds
     * - endTime: null (ride is incomplete)
     * - All statistics: 0 (elapsed, moving, distance, speeds)
     *
     * @return Ride ID (auto-generated by database)
     * @throws Exception if database write fails
     */
    suspend operator fun invoke(): Long {
        val currentTime = System.currentTimeMillis()
        val rideName = RideNameGenerator.generateDefaultName(currentTime)

        // Bug #14 fix: Set startTime = 0 initially, will be set when first track point recorded
        // This ensures timing starts when GPS is actually working, not during initialization
        val newRide = Ride(
            id = 0,  // Auto-generated by database
            name = rideName,
            startTime = 0,  // Bug #14: Will be set when first track point is recorded
            endTime = null,  // Incomplete ride
            elapsedDurationMillis = 0,
            movingDurationMillis = 0,
            manualPausedDurationMillis = 0,
            autoPausedDurationMillis = 0,
            distanceMeters = 0.0,
            avgSpeedMetersPerSec = 0.0,
            maxSpeedMetersPerSec = 0.0
        )

        return rideRepository.createRide(newRide)
    }
}
